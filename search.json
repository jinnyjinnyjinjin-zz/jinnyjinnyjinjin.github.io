[{"content":"문제 int 타입의 배열 prices 에는 다양한 가격의 장난감들이 있는데 이 장난감들 중 마크가 가진 재산 내에서 살 수 있는 최대 갯수의 장난감을 구하는 문제이다. input:\n7 50\t7: 장난감이 들어있는 배열의 길이, 50: 마크의 재산 1 12 5 111 200 1000 10 각 장난감의 가격 output:\n4\t마크가 가진 재산으로 살 수 있는 최대 장난감의 개수 결과 1 2 3 4 5 6 7 8 9 10 11 12 13  static int maximumToys(int[] prices, int k) { int result = 0; int count = 0; Arrays.sort(prices); for (int price : prices) { if (price \u003c= k) { result += price; if (result \u003e k) break; count++; } } return count; }   풀이 result 는 각 장난감 가격의 합을 담을 변수이고, count 는 구입 가능한 장난감의 개수를 담는다. 우선 prices 배열에서 최대한 작은 값의 장난감들을 구입해, 마크가 가진 재산에 맞춰야 하기 때문에 배열을 sort 메소드로 정렬 해 주었다.\n1 2 3  int result = 0; int count = 0; Arrays.sort(prices)   그리고 for each 문을 사용해 prices 배열에 담긴 장남감의 가격을 하나씩 마크의 재산인 k 와 비교하고 장난감의 가격이 k 보다 작거나 같을 경우에는 result 값에 장난감의 가격을 계속 더해 나간다.\n1 2 3 4  for (int price : prices) { if (price \u003c= k) { result += price; // ...   계속해서 장난감의 가격을 더해 나가다가 result 의 값이 k 보다 크게 되면 더 이상 장난감을 구입할 수 없기 때문에 break 를 걸어 반복문을 빠져 나간다. 그리고 이 조건문에서 break 가 걸리지 않으면 count++ 로 살 수 있는 장난감의 개수를 추가한다. 반복문을 반복하다가 모든 작업이 끝나면 count 를 반환한다.\n1 2 3 4 5 6 7 8 9  for (int price : prices) { if (price \u003c= k) { result += price; if (result \u003e k) break; count++; } } return count; }    출처: Mark and Toys | HackerRank\n ","description":"","tags":["Algorithm","Hackerrank"],"title":"[Hackerrank] Mark and Toys","uri":"/posts/2020/11/08-hacerrank-mark-and-toys/"},{"content":"1  conda config --set auto_activate_base false   ","description":"","tags":["Anaconda"],"title":"[Anaconda] 터미널 시작 시 자동으로 활성화되는 virtualenv 비활성화","uri":"/posts/2020/11/08-anaconda-deactivating/"},{"content":"Container 실행 중인 컨테이너 확인\n1  $ docker ps   모든 컨테이너 확인\n1  $ docker ps -a   실행중인 컨테이너 정지\n1  $ docker stop \u003cCONTAINER_ID\u003e   정지시킨 컨테이너 삭제\n1  $ docker rm \u003cCONTAINER_ID\u003e   컨테이너 강제 삭제\n1  $ docker rm -f \u003cCONTAINER_ID\u003e   컨테이너 전체 삭제\n1  $ docker rm $(docker ps -a)   Image 이미지 확인\n1  $ docker images   이미지 삭제\n1  $ docker rmi \u003cIMAGE_ID\u003e   이미지 전체 삭제\n1  $ docker rmi $(docker images -a -q)   ","description":"","tags":["Docker"],"title":"[Docker] 자주 쓰이는 Docker 명령어","uri":"/posts/2020/11/08-docker-frequent-command-usage/"},{"content":"문자열 s 와 문자열을 반복적으로 채워넣을 인덱스 수 n 이 주어졌을 때, 문자 a 의 개수를 찾는 문제다.\n예를 들어, 문자열 s = \"abcac\" 가 주어지고, 이 문자열을 반복할 개수 n = 10 이 주어진다면, n 만큼의 인덱스에 반복해서 문자를 채우면 \"abcacabcac\" 가 된다. 여기서 문자 a 의 개수는 4개가 된다.\n결과 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public long solution(String s, long n) { long x = n / s.length(); long r = n % s.length(); long count = 0; for (int i = 0; i \u003c s.length(); i++) { if (s.charAt(i) == 'a') { count++; } } count *= x; if (r != 0) { for (int i = 0; i \u003c r; i++) { if (s.charAt(i) == 'a') { count++; } } } return count; }   풀이 문자열 s = \"abcac\" 를 n = 10 에 반복해서 채워 넣으면 다음과 같다. n 만큼의 인덱스에 문자열을 반복해서 넣으면 주어진 문자열 s가 2세트로 채워진다. 하지만 만약 문자열 s = \"aba\" 를 n=10 에 채워 넣는다면..? 총 3세트가 만들어지고 마지막 인덱스가 애매하게 남아버린다. 마지막 인덱스까지 빈 인덱스가 없도록 확인해야한다.\n따라서, 총 생겨날 세트의 개수와 남게될 인덱스의 개수를 구했다.\n1 2  long x = n / s.length(); // 총 세트 long r = n % s.length(); // 남게 될 인덱스 개수   그리고 문자열 길이만큼 순환하면서 문자 a 를 찾고 찾을 때마다 count++ 한다.\n1 2 3 4 5  for (int i = 0; i \u003c s.length(); i++) { if (s.charAt(i) == 'a') { count++; } }   그리고 count 를 이전에 구해 둔 총 생겨날 세트의 개수만큼 곱해준다. 각 세트마다 문자열 s 와 동일한 a 의 개수가 있기 때문이다.\n1  count *= x;   마지막으로 세트가 생기고 남게 될 인덱스의 개수가 0이 아니라면 (세트가 인덱스에 딱 맞게 떨어지지 않는다면) 남게되는 인덱스 만큼 순환하며 문자 a 가 있는지 확인하고 있으면 count 를 추가해준다.\n1 2 3 4 5 6 7  if (r != 0) { for (int i = 0; i \u003c r; i++) { if (s.charAt(i) == 'a') { count++; } } }   Test case 여러차례의 시도 중 테스트 케이스에서 런타임 에러가 발생하면서 통과하지 못한 케이스가 있었는데 그 때 테스트 케이스는 다음과 같았다.\n1 2  s = \"kmretasscityylpdhuwjirnqimlkcgxubxmsxpypgzxtenweirknjtasxtvxemtwxuarabssvqdnktqadhyktagjxoanknhgilnm\" n = 736778906400L;   out put\n1  51574523448   처음에는 단순하게 문자열을 n 만큼 순환하며 a 를 찾으려고 했는데 문자열이 n 과 동일하지 않다보니 out of index 에러를 방지하려고 이렇게 저렇게 시도 해봤지만 결국 위와 같은 방법으로 해결할 수 있었다. 알고리즘은 반복되는 규칙을 찾는 것이 중요하다는 사실을 다시 깨달았다.\n 출처: Repeated String | HackerRank\n ","description":"","tags":["Algorithm","Hackerrank"],"title":"[Algorithm] Repeated String","uri":"/posts/2020/11/08-java-hackerrank-algorithm-1/"},{"content":"오더링 서비스란? 이더리움이나 비트코인과 같은 블록체인에서는 허가되지 않은 노드 참가자들도 합의 프로세스에 참여하여 블록을 생성할 수 있다. 그렇기 때문에 이러한 시스템들은 PoW 나 PoS 등과 같은 합의 알고리즘에 기반 해, 분산된 장부를 동기화 시켜 모두가 동일한 데이터를 공유함으로써 무결성을 보장하도록 한다. 하지만 여전히 장부(Ledger) 가 Fork되는 취약점을 가지고 있다.\n그에 반해 하이퍼레저 패브릭에서는 Orderer 라고 불리는 노드가 전달받은 트랜잭션들을 처리한다. 패브릭은 결정론적인 합의 알고리즘에 의존하기 때문에 피어가 오더링 서비스로 부터 생성된 것으로 확인한 모든 블록은 최종적이고 정확해야 한다. 그렇기에 패브릭 장부들은 다른 블록체인 네트워크에서 처럼 Fork 될 수 없다.\n무결성을 높이는 것 외에도, 체인 코드 실행 검증(피어에서 발생)을 오더링으로부터 분리하면 성능과 확장 면에서 패브릭 이점을 제공하여 동일한 노드에서 체인코드를 실행하고 검증 및 오더링을 수행 할 때 발생할 수 있는 병목 현상을 제거한다.\n역할   검증된 트랜잭션들을 차례로 정리하고 패키징하여 블록에 추가\n  피어들이 트랜잭션을 검증 및 커밋할 수 있도록 블록 전파\n  Consensus 트랜잭션을 충돌 없이 순서대로 처리하도록 하고, 분산 장부의 데이터가 모두 같도록 하는 consensus 종류를 선택하여 설정할 수 있다.\n1. Solo  이름처럼 오직 싱글 오더링 노드만 가능 consensus 과정 없음 장애 취약 서비스 개발에 적합하지 않음. 테스트용으로 활용  Fabric v2.0 부터 Deprecated 됨\n  2. Raft  Raft 프로토콜 기반의 CFT(Crash Fault Tolerance) Leader and Follower 모델 각 채널에서 팔로워 노드들에 의해 리더 노드가 선출됨 Kafka 보다 설정 및 관리가 쉬움  3. Kafka  Raft 와 유사함 Leader and Follower 노드 설정을 사용 해 CFT 구현 Kafka 수행을 위해 Zookeeper Ensemble 을 사용함 Fabric v1.0 부터 사용 가능 Kafka cluster 관리가 어려움  Fabric v2.0 부터 Deprecated 됨\n  이렇게 Kafka 또는 Raft 기반의 Orderer 가 트랜잭션을 패키징하고 블록을 생성하고 전파하는 모든 프로세스를 오더링 서비스 라고 한다.\n","description":"","tags":["Hyperledger","Blockchain"],"title":"[Hyperledger]Ordering Service(오더링 서비스)","uri":"/posts/2020/11/08-hyperledger-ordering-service/"},{"content":"개발을 하면서 stash 를 잘 활용하는데 실수로 저장해둔 stash 를 삭제 했던 적이 있었다. 순간 당황스러웠지만 생각했던 것보다 간단하게 아래의 과정으로 복구시킬 수 있었다.\n1. Stash 커밋 찾기 1  git log --graph --oneline --decorate ( git fsck --no-reflog | awk '/dangling commit/ {print $3}' )   위 명령어는 모든 stash 커밋들과 더 이상 참조하지 않는 모든 브랜치를 포함하여, 현재까지 생성한 커밋과 잃어버린 커밋까지 모든 커밋 로그를 출력한다.\n2. Commit Hash 복구 출력된 로그 중에 WIP on 으로 시작하는 커밋 Hash 를 찾아 아래 명령어를 실행하면 잃어버린 커밋을 되찾을 수 있었다.\n1  git stash apply \u003cYOUR_WIP_COMMIT_HASH\u003e   ","description":"","tags":["Git"],"title":"[Git] drop 된 stash 복구하기","uri":"/posts/2020/11/08-git-recover-stashed-commit/"},{"content":"로컬에서 DB 를 시스템에 직접 설치하기보다 도커를 활용해 쉽고 간단하게 컨테이너를 띄워 사용할 수 있다.\n시스템 환경  MacOS Docker 19.03.8 Docker-compose 1.25.4 MariaDB 10.3  1. docker run 명령어로 실행 docker run 명령어로 도커 허브에서 이미지를 바로 다운 받아 컨테이너를 바로 실행 시킨다.\n1  $ docker run --name \u003c컨테이너 이름\u003e -e MYSQL_ROOT_PASSWORD=\u003cdb 접속 비밀번호\u003e -p 3306:3306 -d mariadb:tag   run 다운 받은 도커 이미지로 컨테이너를 실행시키는 명령어. --name 실행시키는 컨테이너의 이름을 지정할 수 있는 옵션. -p 포트를 지정. 호스트에서 3306 으로 접속 시, 컨테이너 3306 으로 포워딩. -d 컨테이너를 백그라운드로 실행. tag 실행하고자 하는 MariaDB 의 버전을 지정. ex) mariadb:10.3\n실행 후, 아래 명령어로 컨테이너가 실행되었는지 확인할 수 있다.\n1  $ docker ps   정상적으로 실행된 컨테이너\n1 2  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfce24bf4cac mariadb:10.3 \"docker-entrypoint.s…\" 48 seconds ago Up 47 seconds 0.0.0.0:3306-\u003e3306/tcp mariadb_test   2. yaml 파일로 실행 yaml 파일을 생성해서 실행시킬 어플리케이션에 대해 더욱 상세한 설정이 가능하다. 파일 실행을 위해서는 docker-compose가 설치되어 있어야 한다.\nyaml 파일 생성\nyaml 파일명은 원하는 이름으로 생성할 수 있는데docker-compose명령어로 실행할 때 옵션값 -f 를 주어야 한다. 반면에, docker-compose up 명령어를 옵션 값 없이 실행하면 자동으로 docker-compose.yaml 을 찾아 실행시킨다. 또한, .yaml 또는 yml 모두 사용 가능하다.\n1  $ vi docker-compose.yaml   다음과 같이 mariadb 컨테이너 실행에 필요한 설정을 yaml 파일 형식에 따라 작성한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  version: '3.1' services: mariadb: image: mariadb:10.3 container_name: mariadb-test environment: MYSQL_ROOT_PASSWORD: password MYSQL_DATABASE: my_db MYSQL_USER: jinnyjinnyjinjin MYSQL_PASSWORD: password ports: - 3306:3306   yaml 파일에서는 services 와 networks 그리고 volumes 설정 파트가 있다.\nversion compose 파일 포맷 버전. services 실행하고자 하는 컨테이너의 설정 값을 셋팅하는 영역. command-line 으로 실행할 때, docker run 하위로 들어가는 파라미터 값을 설정하는 것과 동일. mariadb 실행하고자 하는 서비스명. (직접 지정 가능) container_name 컨테이너명 지정. image 실행하려는 컨테이너의 이미지명과 버전(tag). environment 어플리케이션 환경설정. 데이터베이스에 접속하기 위한 비밀번호 및 유저명 등을 설정한다. port 포트를 지정. 호스트에서 3306 으로 접속 시, 컨테이너 3306 으로 포워딩.\n파일을 생성하고 compose 명령어로 실행한다. -d 옵션을 주어 백그라운드로 실행한다.\n1  $ docker-compose up -d   실행 후 아래 명령어를 입력하면 실행 중인 컨테이너를 확인할 수 있다.\n$ docker ps 1 2  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES dfce24bf4cac mariadb:10.3 \"docker-entrypoint.s…\" 42 minutes ago Up 42 minutes 0.0.0.0:3307-\u003e3307/tcp mariadb_test   ","description":"","tags":["Docker","DB"],"title":"[Docker] Docker로 MariaDB 구동하기","uri":"/posts/2020/11/08-docker-db-maria/"},{"content":"실습환경  Ubuntu 16  우분투 터미널에서 docker login 명령어로 도커 로그인을 시도했을 때, 아래와 같은 에러가 발생 한다면 이렇게 해결할 수 있다.\n에러내용 1 2  Remote error from secret service: org.freedesktop.Secret.Error.IsLocked: Cannot create an item in a locked collection Error saving credentials: error storing credentials - err: exit status 1, out Cannot create an item in a locked collection.   해결방법 gnupg2 를 설치한다. gnupg2 는 안전한 통신과 데이터 저장을 위한 디지털 시그니쳐와 증명서 암호화 툴이다.\n1 2  $ sudo apt-get update $ sudo apt install gnupg2 pass   설치 후, docker login 재시도\n1  $ docker login   결과 1 2 3 4 5 6  Password: WARNING! Your password will be stored unencrypted in /home/User_id/.docker/config.json. Configure a credential helper to remove this warning. See [https://docs.docker.com/engine/reference/commandline/login/#credentials-store](https://docs.docker.com/engine/reference/commandline/login/#credentials-store) Login Succeeded   로컬 /home/User_id/.docker/config.json path 에 내 패스워드가 암호화되지 않고 저장된다는 경고가 뜨고 로그인은 성공한다. 만약 내 암호가 이렇게 저장 되는 것이 내키지 않는다면, 경고문과 함께 안내되는 주소로 접속 해 가이드를 따르면 된다.\n","description":"","tags":["Docker"],"title":"[Docker] Login Error","uri":"/posts/2020/11/08-docker-login/"},{"content":"Hello World👋\n3년차 백엔드 개발자 입니다.\n개발하고 공부하면서 배우고 느낀점들을 기록하고 공유합니다.🙌\n","description":"","tags":null,"title":"About","uri":"/about/"},{"content":"이진 트리의 한 종류 (이진 힙 - binary heap)   루트(root) 노드가 언제나 최댓값 또는 최솟값을 가짐\n 최대 힙(max heap), 최소 힙(min heap)    완전 이진 트리여야 함\n 최대 힙(max) 힙  부모 노드가 자식 노드보다 큰 값을 가지고 있음 재귀적으로도 정의됨      이진 탐색트리와의 비교  원소들은 완전히 크기 순으로 정렬되어 있는가?  이진 탐색 트리에서는 그렇지만 최대 힙, 최소 힙에서는 그렇지 않고 느슨하게 정렬되어 있다.   특정 키 값을 가지는 원소를 빠르게 검색할 수 있는가?  이진 탐색 트리에서는 일반적으로 키 값으로 왼쪽 오른쪽을 찾아가기 때문에 빠르게 검색할 수 있지만 힙에서는 특정 키 값이 힙 안에 들어 있는가를 검색하는데에 좋은 방법이 없다.   부가의 제약 조건은 어떤 것인가?  힙은 이진 탐색 트리에서 완전 이진트리여야 한다는 부가적인 제약 조건을 가지고 있다.    최대 힙(Max Heap)의 추상적 자료구조 연산의 정의  insert(item) - 새로운 원소를 삽입 remove() - 최대 원소(root node)를 반환함과 동시에 이 노드를 삭제  순환이나 검색은 힙에서 얻을 수 있는 좋은 연산이 아님\n데이터 표현의 설계 배열을 이용한 이진 트리의 표현 노드 번호 n을 기준으로  왼쪽 자식의 번호 = 2 * n 오른쪽 자식의 번호: 2 * n + 1 부모 노드의 번호: n // 2  따라서 배열을 이용해 이진 트리를 구현할 수 있다. 최대 힙에 원소 삽입  트리의 마지막 자리에 새로운 원소를 임시로 저장  완전 이진 트리의 성질을 만족   부모 노드와 키 값을 비교하여 위로, 위로, 이동  복잡도 원소의 개수가 n인 최대 힙에 새로운 원소 삽입 ➡️ 부모 노드와의 대소 비교 최대 회수 최악 복잡도:\n최대 힙에서 원소의 삭제  루트 노드의 제거 - 이것이 원소들 중 최댓값 (루트 노드를 제거 했을 때에도 완전 이진 트리를 만족하기 위해서) 트리 마지막 자리 노드를 임시로 루트 노드의 자리에 배치 (아직 최대값이 아닐 수도 있기 때문에) 자식 노드들과의 값 비교 후 아래로, 아래로 이동  자식은 둘 있을 수도 있는데, 어느 쪽으로 이동? ➡️ 둘 중에 더 큰 값을 기준으로 임시로 배치된 노드가 아래로 이동하게 된다.    복잡도 원소의 개수가 n인 최대 힙에서 원소 삭제 ➡️ 자식 노드들과의 대소 비교 최대 회수 최악 복잡도:\n최대/최소 힙의 응용 우선 순위 큐 (priority queue) ➡️ Enqueue 할 때, 느슨한 정렬 을 이루고 있도록 함: O(logN)\n➡️ Dequeue 할 때, 최댓값을 순서대로 추출: O(logN)\n힙 정렬(heap sort) ➡️ 정렬되지 않은 원소들을 아무 순서로나 최대 힙에 삽입: O(logN)\n➡️ 삽입이 끝나면, 힙이 비게 될 때까지 하나씩 삭제: O(logN)\n➡️ 원소들이 삭제된 순서가 원소들의 정렬 순서\n➡️ 정렬 알고리즘의 복잡도: O(NlogN)\n 참조: 어서와! 자료구조와 알고리즘은 처음이지?\n ","description":"","tags":["자료구조"],"title":"[자료구조] Heap(힙)","uri":"/posts/2020/11/07-ds-heap/"}]
