<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Me, Myself &amp; Dev</title>
        <link>https://jinnyjinnyjinjin.github.io/</link>
        <description>MemE is a powerful and highly customizable GoHugo theme for personal blogs.</description>
        <generator>Hugo 0.78.0 https://gohugo.io/</generator>
        
            <language>en</language>
        
        
            <managingEditor>kkam2ya@gmail.com (jinnyjinnyjinjin)</managingEditor>
        
        
            <webMaster>kkam2ya@gmail.com (jinnyjinnyjinjin)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)</copyright>
        
        <lastBuildDate>Sun, 08 Nov 2020 13:46:15 &#43;0900</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://jinnyjinnyjinjin.github.io/rss.xml" />
        
        
            <item>
                <title>[자료구조]Heap(힙)</title>
                <link>https://jinnyjinnyjinjin.github.io/posts/2020/11/07-ds-heap/</link>
                <guid isPermaLink="true">https://jinnyjinnyjinjin.github.io/posts/2020/11/07-ds-heap/</guid>
                <pubDate>Sat, 07 Nov 2020 17:47:51 &#43;0900</pubDate>
                
                
                
                    <description>&lt;h3 id=&#34;이진-트리의-한-종류-이진-힙---binary-heap&#34;&gt;이진 트리의 한 종류 (이진 힙 - binary heap)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;루트(root) 노드가 언제나 최댓값 또는 최솟값을 가짐&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최대 힙(max heap), 최소 힙(min heap)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;완전 이진 트리여야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최대 힙(max) 힙
&lt;ul&gt;
&lt;li&gt;부모 노드가 자식 노드보다 큰 값을 가지고 있음&lt;/li&gt;
&lt;li&gt;재귀적으로도 정의됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;이진-탐색트리와의-비교&#34;&gt;이진 탐색트리와의 비교&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;원소들은 완전히 크기 순으로 정렬되어 있는가?
&lt;ul&gt;
&lt;li&gt;이진 탐색 트리에서는 그렇지만 최대 힙, 최소 힙에서는 그렇지 않고 느슨하게 정렬되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;특정 키 값을 가지는 원소를 빠르게 검색할 수 있는가?
&lt;ul&gt;
&lt;li&gt;이진 탐색 트리에서는 일반적으로 키 값으로 왼쪽 오른쪽을 찾아가기 때문에 빠르게 검색할 수 있지만 힙에서는 특정 키 값이 힙 안에 들어 있는가를 검색하는데에 좋은 방법이 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;부가의 제약 조건은 어떤 것인가?
&lt;ul&gt;
&lt;li&gt;힙은 이진 탐색 트리에서 완전 이진트리여야 한다는 부가적인 제약 조건을 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;최대-힙max-heap의-추상적-자료구조&#34;&gt;최대 힙(Max Heap)의 추상적 자료구조&lt;/h3&gt;
&lt;h4 id=&#34;연산의-정의&#34;&gt;연산의 정의&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;insert(item)&lt;/code&gt; - 새로운 원소를 삽입&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove()&lt;/code&gt; - 최대 원소(root node)를 반환함과 동시에 이 노드를 삭제&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&#34;color: rgb(255, 51, 153);&#34;&gt;순환이나 검색은 힙에서 얻을 수 있는 좋은 연산이 아님&lt;/p&gt;
&lt;h3 id=&#34;데이터-표현의-설계&#34;&gt;데이터 표현의 설계&lt;/h3&gt;
&lt;h4 id=&#34;배열을-이용한-이진-트리의-표현&#34;&gt;배열을 이용한 이진 트리의 표현&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://jinnyjinnyjinjin.github.io/images/2020/11/max_heap.jpeg&#34; alt=&#34;max_heap&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;노드-번호-n을-기준으로&#34;&gt;노드 번호 n을 기준으로&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽 자식의 번호 = &lt;code&gt;2 * n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;오른쪽 자식의 번호: &lt;code&gt;2 * n + 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;부모 노드의 번호: &lt;code&gt;n // 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;따라서 배열을 이용해 이진 트리를 구현할 수 있다.
&lt;img src=&#34;https://jinnyjinnyjinjin.github.io/images/2020/11/max_heap_array.png&#34; alt=&#34;max_heap_array&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;최대-힙에-원소-삽입&#34;&gt;최대 힙에 원소 삽입&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;트리의 마지막 자리에 새로운 원소를 임시로 저장
&lt;ul&gt;
&lt;li&gt;완전 이진 트리의 성질을 만족&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;부모 노드와 키 값을 비교하여 위로, 위로, 이동&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;복잡도&#34;&gt;복잡도&lt;/h4&gt;
&lt;h5 id=&#34;원소의-개수가-n인-최대-힙에-새로운-원소-삽입&#34;&gt;원소의 개수가 n인 최대 힙에 새로운 원소 삽입&lt;/h5&gt;
&lt;p&gt;➡️ 부모 노드와의 대소 비교 최대 회수 최악 복잡도:&lt;br&gt;
&lt;img src=&#34;https://jinnyjinnyjinjin.github.io/images/2020/11/complexity.jpeg&#34; alt=&#34;complexity&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;최대-힙에서-원소의-삭제&#34;&gt;최대 힙에서 원소의 삭제&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;루트 노드의 제거 - 이것이 원소들 중 최댓값&lt;/li&gt;
&lt;li&gt;(루트 노드를 제거 했을 때에도 완전 이진 트리를 만족하기 위해서) 트리 마지막 자리 노드를 임시로 루트 노드의 자리에 배치&lt;/li&gt;
&lt;li&gt;(아직 최대값이 아닐 수도 있기 때문에) 자식 노드들과의 값 비교 후 아래로, 아래로 이동
&lt;ul&gt;
&lt;li&gt;자식은 둘 있을 수도 있는데, 어느 쪽으로 이동?
➡️ 둘 중에 더 큰 값을 기준으로 임시로 배치된 노드가 아래로 이동하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;복잡도-1&#34;&gt;복잡도&lt;/h4&gt;
&lt;h5 id=&#34;원소의-개수가-n인-최대-힙에서-원소-삭제&#34;&gt;원소의 개수가 n인 최대 힙에서 원소 삭제&lt;/h5&gt;
&lt;p&gt;➡️ 자식 노드들과의 대소 비교 최대 회수 최악 복잡도:&lt;br&gt;
&lt;img src=&#34;https://jinnyjinnyjinjin.github.io/images/2020/11/complexity.jpeg&#34; alt=&#34;complexity&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;최대최소-힙의-응용&#34;&gt;최대/최소 힙의 응용&lt;/h3&gt;
&lt;h4 id=&#34;우선-순위-큐-priority-queue&#34;&gt;우선 순위 큐 (priority queue)&lt;/h4&gt;
&lt;p&gt;➡️ Enqueue 할 때, &lt;code&gt;느슨한 정렬&lt;/code&gt; 을 이루고 있도록 함: &lt;strong&gt;O(logN)&lt;/strong&gt;&lt;br&gt;
➡️ Dequeue 할 때, 최댓값을 순서대로 추출: &lt;strong&gt;O(logN)&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;힙-정렬heap-sort&#34;&gt;힙 정렬(heap sort)&lt;/h4&gt;
&lt;p&gt;➡️ 정렬되지 않은 원소들을 아무 순서로나 최대 힙에 삽입: &lt;strong&gt;O(logN)&lt;/strong&gt;&lt;br&gt;
➡️ 삽입이 끝나면, 힙이 비게 될 때까지 하나씩 삭제: &lt;strong&gt;O(logN)&lt;/strong&gt;&lt;br&gt;
➡️ 원소들이 삭제된 순서가 원소들의 정렬 순서&lt;br&gt;
➡️ 정렬 알고리즘의 복잡도: &lt;strong&gt;O(NlogN)&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;blockquote&gt;
&lt;p&gt;참조: &lt;a href=&#34;https://programmers.co.kr/learn/courses/57&#34;&gt;어서와! 자료구조와 알고리즘은 처음이지?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                
                
                    
                        
                    
                        
                            
                                
                                
                                
                                    <category domain="https://jinnyjinnyjinjin.github.io/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/">자료구조</category>
                                
                            
                        
                    
                
            </item>
        
    </channel>
</rss>
